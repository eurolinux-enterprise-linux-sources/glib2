From a075179d294a825747327a3ff8b98dc6097cd2de Mon Sep 17 00:00:00 2001
From: Matthew Barnes <mbarnes@redhat.com>
Date: Tue, 9 Sep 2014 14:42:35 -0400
Subject: [PATCH 1/8] GDBusProxy: Fix race condition when unsubscribing from signals

This was reported in bug 651133.

https://bugzilla.gnome.org/show_bug.cgi?id=651133

Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit 7e0f890e3811c23d331079c3e878d0c1df4ae282)

Conflicts:

	gio/gdbusproxy.c
---
 gio/gdbusproxy.c |  118 ++++++++++++++++++++++++++++++++++++++++++++----------
 1 files changed, 97 insertions(+), 21 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 986b021..32292db 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -79,6 +79,34 @@
  * <example id="gdbus-wellknown-proxy"><title>GDBusProxy for a well-known-name</title><programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="../../../../gio/tests/gdbus-example-watch-proxy.c"><xi:fallback>FIXME: MISSING XINCLUDE CONTENT</xi:fallback></xi:include></programlisting></example>
  */
 
+/* ---------------------------------------------------------------------------------------------------- */
+
+G_LOCK_DEFINE_STATIC (signal_subscription_lock);
+
+typedef struct
+{
+  volatile gint ref_count;
+  GDBusProxy *proxy;
+} SignalSubscriptionData;
+
+static SignalSubscriptionData *
+signal_subscription_ref (SignalSubscriptionData *data)
+{
+  g_atomic_int_inc (&data->ref_count);
+  return data;
+}
+
+static void
+signal_subscription_unref (SignalSubscriptionData *data)
+{
+  if (g_atomic_int_dec_and_test (&data->ref_count))
+    {
+      g_slice_free (SignalSubscriptionData, data);
+    }
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
 struct _GDBusProxyPrivate
 {
   GBusType bus_type;
@@ -100,10 +128,12 @@ struct _GDBusProxyPrivate
 
   GDBusInterfaceInfo *expected_interface;
 
-  guint properties_changed_subscriber_id;
-  guint signals_subscriber_id;
+  guint properties_changed_subscription_id;
+  guint signals_subscription_id;
 
   gboolean initialized;
+
+  SignalSubscriptionData *signal_subscription_data;
 };
 
 enum
@@ -138,6 +168,22 @@ G_DEFINE_TYPE_WITH_CODE (GDBusProxy, g_dbus_proxy, G_TYPE_OBJECT,
                          );
 
 static void
+g_dbus_proxy_dispose (GObject *object)
+{
+  GDBusProxy *proxy = G_DBUS_PROXY (object);
+  G_LOCK (signal_subscription_lock);
+  if (proxy->priv->signal_subscription_data != NULL)
+    {
+      proxy->priv->signal_subscription_data->proxy = NULL;
+      signal_subscription_unref (proxy->priv->signal_subscription_data);
+      proxy->priv->signal_subscription_data = NULL;
+    }
+  G_UNLOCK (signal_subscription_lock);
+
+  G_OBJECT_CLASS (g_dbus_proxy_parent_class)->dispose (object);
+}
+
+static void
 g_dbus_proxy_finalize (GObject *object)
 {
   GDBusProxy *proxy = G_DBUS_PROXY (object);
@@ -148,13 +194,13 @@ g_dbus_proxy_finalize (GObject *object)
     g_dbus_connection_signal_unsubscribe (proxy->priv->connection,
                                           proxy->priv->name_owner_changed_subscription_id);
 
-  if (proxy->priv->properties_changed_subscriber_id > 0)
+  if (proxy->priv->properties_changed_subscription_id > 0)
     g_dbus_connection_signal_unsubscribe (proxy->priv->connection,
-                                          proxy->priv->properties_changed_subscriber_id);
+                                          proxy->priv->properties_changed_subscription_id);
 
-  if (proxy->priv->signals_subscriber_id > 0)
+  if (proxy->priv->signals_subscription_id > 0)
     g_dbus_connection_signal_unsubscribe (proxy->priv->connection,
-                                          proxy->priv->signals_subscriber_id);
+                                          proxy->priv->signals_subscription_id);
 
   g_object_unref (proxy->priv->connection);
   g_free (proxy->priv->name);
@@ -271,6 +317,7 @@ g_dbus_proxy_class_init (GDBusProxyClass *klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 
+  gobject_class->dispose      = g_dbus_proxy_dispose;
   gobject_class->finalize     = g_dbus_proxy_finalize;
   gobject_class->set_property = g_dbus_proxy_set_property;
   gobject_class->get_property = g_dbus_proxy_get_property;
@@ -535,6 +582,9 @@ static void
 g_dbus_proxy_init (GDBusProxy *proxy)
 {
   proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, G_TYPE_DBUS_PROXY, GDBusProxyPrivate);
+  proxy->priv->signal_subscription_data = g_slice_new0 (SignalSubscriptionData);
+  proxy->priv->signal_subscription_data->ref_count = 1;
+  proxy->priv->signal_subscription_data->proxy = proxy;
   proxy->priv->properties = g_hash_table_new_full (g_str_hash,
                                                    g_str_equal,
                                                    g_free,
@@ -743,7 +793,15 @@ on_signal_received (GDBusConnection *connection,
                     GVariant        *parameters,
                     gpointer         user_data)
 {
-  GDBusProxy *proxy = G_DBUS_PROXY (user_data);
+  SignalSubscriptionData *data = user_data;
+  GDBusProxy *proxy;
+
+  G_LOCK (signal_subscription_lock);
+  proxy = data->proxy;
+  if (proxy == NULL)
+    goto out;
+  g_object_ref (proxy);
+  G_UNLOCK (signal_subscription_lock);
 
   if (!proxy->priv->initialized)
     goto out;
@@ -758,7 +816,8 @@ on_signal_received (GDBusConnection *connection,
                  signal_name,
                  parameters);
  out:
-  ;
+  if (proxy != NULL)
+    g_object_unref (proxy);
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -772,8 +831,8 @@ on_properties_changed (GDBusConnection *connection,
                        GVariant        *parameters,
                        gpointer         user_data)
 {
-  GDBusProxy *proxy = G_DBUS_PROXY (user_data);
-  GError *error;
+  SignalSubscriptionData *data = user_data;
+  GDBusProxy *proxy;
   const gchar *interface_name_for_signal;
   GVariant *changed_properties;
   gchar **invalidated_properties;
@@ -782,7 +841,13 @@ on_properties_changed (GDBusConnection *connection,
   GVariant *value;
   guint n;
 
-  error = NULL;
+  G_LOCK (signal_subscription_lock);
+  proxy = data->proxy;
+  if (proxy == NULL)
+    goto out;
+  g_object_ref (proxy);
+  G_UNLOCK (signal_subscription_lock);
+
   changed_properties = NULL;
   invalidated_properties = NULL;
 
@@ -831,6 +896,8 @@ on_properties_changed (GDBusConnection *connection,
   if (changed_properties != NULL)
     g_variant_unref (changed_properties);
   g_free (invalidated_properties);
+  if (proxy != NULL)
+    g_object_unref (proxy);
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -955,10 +1022,18 @@ on_name_owner_changed (GDBusConnection *connection,
                        GVariant         *parameters,
                        gpointer          user_data)
 {
-  GDBusProxy *proxy = G_DBUS_PROXY (user_data);
+  SignalSubscriptionData *data = user_data;
+  GDBusProxy *proxy;
   const gchar *old_owner;
   const gchar *new_owner;
 
+  G_LOCK (signal_subscription_lock);
+  proxy = data->proxy;
+  if (proxy == NULL)
+    goto out;
+  g_object_ref (proxy);
+  G_UNLOCK (signal_subscription_lock);
+
   /* if we are already trying to load properties, cancel that */
   if (proxy->priv->get_all_cancellable != NULL)
     {
@@ -1053,7 +1128,8 @@ on_name_owner_changed (GDBusConnection *connection,
     }
 
  out:
-  ;
+  if (proxy != NULL)
+    g_object_unref (proxy);
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -1368,7 +1444,7 @@ async_initable_init_first (GAsyncInitable *initable)
   if (!(proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES))
     {
       /* subscribe to PropertiesChanged() */
-      proxy->priv->properties_changed_subscriber_id =
+      proxy->priv->properties_changed_subscription_id =
         g_dbus_connection_signal_subscribe (proxy->priv->connection,
                                             proxy->priv->name,
                                             "org.freedesktop.DBus.Properties",
@@ -1377,14 +1453,14 @@ async_initable_init_first (GAsyncInitable *initable)
                                             proxy->priv->interface_name,
                                             G_DBUS_SIGNAL_FLAGS_NONE,
                                             on_properties_changed,
-                                            proxy,
-                                            NULL);
+                                            signal_subscription_ref (proxy->priv->signal_subscription_data),
+                                            (GDestroyNotify) signal_subscription_unref);
     }
 
   if (!(proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS))
     {
       /* subscribe to all signals for the object */
-      proxy->priv->signals_subscriber_id =
+      proxy->priv->signals_subscription_id =
         g_dbus_connection_signal_subscribe (proxy->priv->connection,
                                             proxy->priv->name,
                                             proxy->priv->interface_name,
@@ -1393,8 +1469,8 @@ async_initable_init_first (GAsyncInitable *initable)
                                             NULL,                        /* arg0 */
                                             G_DBUS_SIGNAL_FLAGS_NONE,
                                             on_signal_received,
-                                            proxy,
-                                            NULL);
+                                            signal_subscription_ref (proxy->priv->signal_subscription_data),
+                                            (GDestroyNotify) signal_subscription_unref);
     }
 
   if (proxy->priv->name != NULL && !g_dbus_is_unique_name (proxy->priv->name))
@@ -1408,8 +1484,8 @@ async_initable_init_first (GAsyncInitable *initable)
                                             proxy->priv->name,       /* arg0 */
                                             G_DBUS_SIGNAL_FLAGS_NONE,
                                             on_name_owner_changed,
-                                            proxy,
-                                            NULL);
+                                            signal_subscription_ref (proxy->priv->signal_subscription_data),
+                                            (GDestroyNotify) signal_subscription_unref);
     }
 }
 
-- 
1.7.1


From 27679fa1e8e2f99fe1c684138313df3d82d0d544 Mon Sep 17 00:00:00 2001
From: David Zeuthen <davidz@redhat.com>
Date: Thu, 26 May 2011 09:54:47 -0400
Subject: [PATCH 2/8] GDBusProxy: Add locking and notes/guarantees about MT safety

This was discussed in

 https://bugzilla.gnome.org/show_bug.cgi?id=651133

Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit c0f4a63c89332ee18c1ddf1fe48fe04b16b27fa3)
---
 gio/gdbusproxy.c |   48 ++++++++++++++++++++++++++++++++++++++++++++----
 1 files changed, 44 insertions(+), 4 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 32292db..4ee7e24 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -74,11 +74,20 @@
  * way of working with proxies is to subclass #GDBusProxy, and have
  * more natural properties and signals in your derived class.
  *
+ * A #GDBusProxy instance can be used from multiple threads but note
+ * that all signals (e.g. #GDBusProxy::g-signal, #GDBusProxy::g-properties
+ * and #GObject::notify) are emitted in the
+ * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
+ * of the thread where the instance was constructed.
+ *
  * See <xref linkend="gdbus-example-proxy-subclass"/> for an example.
  *
  * <example id="gdbus-wellknown-proxy"><title>GDBusProxy for a well-known-name</title><programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="../../../../gio/tests/gdbus-example-watch-proxy.c"><xi:fallback>FIXME: MISSING XINCLUDE CONTENT</xi:fallback></xi:include></programlisting></example>
  */
 
+/* lock protecting the properties GHashTable */
+G_LOCK_DEFINE_STATIC (properties_lock);
+
 /* ---------------------------------------------------------------------------------------------------- */
 
 G_LOCK_DEFINE_STATIC (signal_subscription_lock);
@@ -621,6 +630,8 @@ g_dbus_proxy_get_cached_property_names (GDBusProxy  *proxy)
 
   g_return_val_if_fail (G_IS_DBUS_PROXY (proxy), NULL);
 
+  G_LOCK (properties_lock);
+
   names = NULL;
   if (g_hash_table_size (proxy->priv->properties) == 0)
     goto out;
@@ -636,6 +647,7 @@ g_dbus_proxy_get_cached_property_names (GDBusProxy  *proxy)
   names = (gchar **) g_ptr_array_free (p, FALSE);
 
  out:
+  G_UNLOCK (properties_lock);
   return names;
 }
 
@@ -686,6 +698,8 @@ g_dbus_proxy_get_cached_property (GDBusProxy   *proxy,
   g_return_val_if_fail (G_IS_DBUS_PROXY (proxy), NULL);
   g_return_val_if_fail (property_name != NULL, NULL);
 
+  G_LOCK (properties_lock);
+
   value = g_hash_table_lookup (proxy->priv->properties, property_name);
   if (value == NULL)
     {
@@ -698,6 +712,7 @@ g_dbus_proxy_get_cached_property (GDBusProxy   *proxy,
   g_variant_ref (value);
 
  out:
+  G_UNLOCK (properties_lock);
   return value;
 }
 
@@ -754,6 +769,8 @@ g_dbus_proxy_set_cached_property (GDBusProxy   *proxy,
   g_return_if_fail (G_IS_DBUS_PROXY (proxy));
   g_return_if_fail (property_name != NULL);
 
+  G_LOCK (properties_lock);
+
   if (value != NULL)
     {
       info = lookup_property_info_or_warn (proxy, property_name);
@@ -779,7 +796,7 @@ g_dbus_proxy_set_cached_property (GDBusProxy   *proxy,
     }
 
  out:
-  ;
+  G_UNLOCK (properties_lock);
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -822,6 +839,7 @@ on_signal_received (GDBusConnection *connection,
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+/* must hold properties_lock */
 static void
 on_properties_changed (GDBusConnection *connection,
                        const gchar     *sender_name,
@@ -873,6 +891,8 @@ on_properties_changed (GDBusConnection *connection,
   if (g_strcmp0 (interface_name_for_signal, proxy->priv->interface_name) != 0)
     goto out;
 
+  G_LOCK (properties_lock);
+
   g_variant_iter_init (&iter, changed_properties);
   while (g_variant_iter_next (&iter, "{sv}", &key, &value))
     {
@@ -886,6 +906,8 @@ on_properties_changed (GDBusConnection *connection,
       g_hash_table_remove (proxy->priv->properties, invalidated_properties[n]);
     }
 
+  G_UNLOCK (properties_lock);
+
   /* emit signal */
   g_signal_emit (proxy, signals[PROPERTIES_CHANGED_SIGNAL],
                  0,
@@ -909,6 +931,7 @@ process_get_all_reply (GDBusProxy *proxy,
   GVariantIter *iter;
   gchar *key;
   GVariant *value;
+  guint num_properties;
 
   if (!g_variant_is_of_type (result, G_VARIANT_TYPE ("(a{sv})")))
     {
@@ -917,6 +940,8 @@ process_get_all_reply (GDBusProxy *proxy,
       goto out;
     }
 
+  G_LOCK (properties_lock);
+
   g_variant_get (result, "(a{sv})", &iter);
   while (g_variant_iter_next (iter, "{sv}", &key, &value))
     {
@@ -926,8 +951,11 @@ process_get_all_reply (GDBusProxy *proxy,
     }
   g_variant_iter_free (iter);
 
+  num_properties = g_hash_table_size (proxy->priv->properties);
+  G_UNLOCK (properties_lock);
+
   /* Synthesize ::g-properties-changed changed */
-  if (g_hash_table_size (proxy->priv->properties) > 0)
+  if (num_properties > 0)
     {
       GVariant *changed_properties;
       const gchar *invalidated_properties[1] = {NULL};
@@ -994,7 +1022,9 @@ on_name_owner_changed_get_all_cb (GDBusConnection *connection,
       data->proxy->priv->name_owner = data->name_owner;
       data->name_owner = NULL; /* to avoid an extra copy, we steal the string */
 
+      G_LOCK (properties_lock);
       g_hash_table_remove_all (data->proxy->priv->properties);
+      G_UNLOCK (properties_lock);
       if (result != NULL)
         {
           process_get_all_reply (data->proxy, result);
@@ -1052,6 +1082,8 @@ on_name_owner_changed (GDBusConnection *connection,
       g_free (proxy->priv->name_owner);
       proxy->priv->name_owner = NULL;
 
+      G_LOCK (properties_lock);
+
       /* Synthesize ::g-properties-changed changed */
       if (!(proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES) &&
           g_hash_table_size (proxy->priv->properties) > 0)
@@ -1074,6 +1106,8 @@ on_name_owner_changed (GDBusConnection *connection,
           /* ... throw out the properties ... */
           g_hash_table_remove_all (proxy->priv->properties);
 
+          G_UNLOCK (properties_lock);
+
           /* ... and finally emit the ::g-properties-changed signal */
           g_signal_emit (proxy, signals[PROPERTIES_CHANGED_SIGNAL],
                          0,
@@ -1082,6 +1116,10 @@ on_name_owner_changed (GDBusConnection *connection,
           g_variant_unref (changed_properties);
           g_ptr_array_unref (invalidated_properties);
         }
+      else
+        {
+          G_UNLOCK (properties_lock);
+        }
       g_object_notify (G_OBJECT (proxy), "g-name-owner");
     }
   else
@@ -1094,7 +1132,9 @@ on_name_owner_changed (GDBusConnection *connection,
         {
           g_free (proxy->priv->name_owner);
           proxy->priv->name_owner = g_strdup (new_owner);
+          G_LOCK (properties_lock);
           g_hash_table_remove_all (proxy->priv->properties);
+          G_UNLOCK (properties_lock);
           g_object_notify (G_OBJECT (proxy), "g-name-owner");
         }
       else
@@ -2323,8 +2363,8 @@ get_destination_for_call (GDBusProxy *proxy)
  *
  * This is an asynchronous method. When the operation is finished,
  * @callback will be invoked in the
- * <link linkend="g-main-context-push-thread-default">thread-default
- * main loop</link> of the thread you are calling this method from.
+ * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
+ * of the thread you are calling this method from.
  * You can then call g_dbus_proxy_call_finish() to get the result of
  * the operation. See g_dbus_proxy_call_sync() for the synchronous
  * version of this method.
-- 
1.7.1


From 79def54b6eaf165c9e82b4abd19981944cc5a2d6 Mon Sep 17 00:00:00 2001
From: David Zeuthen <davidz@redhat.com>
Date: Thu, 26 May 2011 10:07:38 -0400
Subject: [PATCH 3/8] GDBusProxy: Fix incorrect locking

Pointed out by mclasen.

Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit 06f5de77f04f16480e642f7efee9dc4bdfba6778)
---
 gio/gdbusproxy.c |   36 +++++++++++++++++++++++++++---------
 1 files changed, 27 insertions(+), 9 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 4ee7e24..d3d1e55 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -816,9 +816,15 @@ on_signal_received (GDBusConnection *connection,
   G_LOCK (signal_subscription_lock);
   proxy = data->proxy;
   if (proxy == NULL)
-    goto out;
-  g_object_ref (proxy);
-  G_UNLOCK (signal_subscription_lock);
+    {
+      G_UNLOCK (signal_subscription_lock);
+      goto out;
+    }
+  else
+    {
+      g_object_ref (proxy);
+      G_UNLOCK (signal_subscription_lock);
+    }
 
   if (!proxy->priv->initialized)
     goto out;
@@ -862,9 +868,15 @@ on_properties_changed (GDBusConnection *connection,
   G_LOCK (signal_subscription_lock);
   proxy = data->proxy;
   if (proxy == NULL)
-    goto out;
-  g_object_ref (proxy);
-  G_UNLOCK (signal_subscription_lock);
+    {
+      G_UNLOCK (signal_subscription_lock);
+      goto out;
+    }
+  else
+    {
+      g_object_ref (proxy);
+      G_UNLOCK (signal_subscription_lock);
+    }
 
   changed_properties = NULL;
   invalidated_properties = NULL;
@@ -1060,9 +1072,15 @@ on_name_owner_changed (GDBusConnection *connection,
   G_LOCK (signal_subscription_lock);
   proxy = data->proxy;
   if (proxy == NULL)
-    goto out;
-  g_object_ref (proxy);
-  G_UNLOCK (signal_subscription_lock);
+    {
+      G_UNLOCK (signal_subscription_lock);
+      goto out;
+    }
+  else
+    {
+      g_object_ref (proxy);
+      G_UNLOCK (signal_subscription_lock);
+    }
 
   /* if we are already trying to load properties, cancel that */
   if (proxy->priv->get_all_cancellable != NULL)
-- 
1.7.1


From 6c69d81f4c561bd884b02ea5cf791c99e71d0b06 Mon Sep 17 00:00:00 2001
From: Matthias Clasen <mclasen@redhat.com>
Date: Sat, 13 Aug 2011 16:09:41 -0400
Subject: [PATCH 4/8] GDBusProxy: on_properties_changed initialize some variables

This avoids calling g_variant_unref and g_free on uninitialized memory
if PropertiesChanged is received in the creating thread's thread-default
main context's thread, at the same time as releasing the last ref in
another thread. This would result in "goto out" before the variables
freed after that label had been initialized to NULL.

Based on a patch by Simon McVittie, bug 656282

(cherry picked from commit ae496a52a92c137b624eee3f5cf54e7756143086)
---
 gio/gdbusproxy.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index d3d1e55..1a80227 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -865,6 +865,9 @@ on_properties_changed (GDBusConnection *connection,
   GVariant *value;
   guint n;
 
+  changed_properties = NULL;
+  invalidated_properties = NULL;
+
   G_LOCK (signal_subscription_lock);
   proxy = data->proxy;
   if (proxy == NULL)
@@ -878,9 +881,6 @@ on_properties_changed (GDBusConnection *connection,
       G_UNLOCK (signal_subscription_lock);
     }
 
-  changed_properties = NULL;
-  invalidated_properties = NULL;
-
   if (!proxy->priv->initialized)
     goto out;
 
-- 
1.7.1


From 6ca3379a9f96935ea6554b632a11703d38284722 Mon Sep 17 00:00:00 2001
From: Simon McVittie <simon.mcvittie@collabora.co.uk>
Date: Mon, 15 Aug 2011 15:57:59 +0100
Subject: [PATCH 5/8] GDBusProxy: if a well-known name is not owned, don't GetAll from the dbus-daemon

If you run:

    ( cd gio/tests && G_DBUS_DEBUG=all ./gdbus-proxy-well-known-name )

you can see that in the case where the name com.example.TestService isn't
owned yet, the GDBusProxy calls GetAll() with no destination, resulting
in an error reply from the peer (the dbus-daemon itself). That's clearly
not right!

However, if priv->name is NULL, that indicates the special case where we
really do want to talk directly to a peer, instead of via the bus daemon
(most likely to be used on peer-to-peer connections); in that special
case, do call GetAll().

Signed-off-by: Simon McVittie <simon.mcvittie@collabora.co.uk>
Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit 20387d262ff104f9de3defc264c5c2010d272857)
---
 gio/gdbusproxy.c |   21 ++++++++++++++++++++-
 1 files changed, 20 insertions(+), 1 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 1a80227..69a38e1 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -1255,6 +1255,7 @@ async_init_get_name_owner_cb (GDBusConnection *connection,
                               gpointer         user_data)
 {
   AsyncInitData *data = user_data;
+  gboolean get_all;
 
   if (res != NULL)
     {
@@ -1289,7 +1290,25 @@ async_init_get_name_owner_cb (GDBusConnection *connection,
         }
     }
 
-  if (!(data->proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES))
+  get_all = TRUE;
+
+  if (data->proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES)
+    {
+      /* Don't load properties if the API user doesn't want them */
+      get_all = FALSE;
+    }
+  else if (data->proxy->priv->name_owner == NULL &&
+           data->proxy->priv->name != NULL)
+    {
+      /* Don't attempt to load properties if the name_owner is NULL (which
+       * usually means the name isn't owned), unless name is also NULL (which
+       * means we actually wanted to talk to the directly-connected process -
+       * either dbus-daemon or a peer - instead of going via dbus-daemon)
+       */
+        get_all = FALSE;
+    }
+
+  if (get_all)
     {
       /* load all properties asynchronously */
       g_dbus_connection_call (data->proxy->priv->connection,
-- 
1.7.1


From 89ca0633048098639ff999cd4e0a38d9a0ad1063 Mon Sep 17 00:00:00 2001
From: Simon McVittie <simon.mcvittie@collabora.co.uk>
Date: Mon, 8 Aug 2011 18:22:42 +0100
Subject: [PATCH 6/8] g_dbus_proxy_get_property: use accessors for all mutable state

These ought to have thread-locking, and having it in the accessor seems
better than duplicating it here.

Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit 03ae974f7cc992450907401f45e7de645caff141)
---
 gio/gdbusproxy.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 69a38e1..0646b98 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -248,7 +248,7 @@ g_dbus_proxy_get_property (GObject    *object,
       break;
 
     case PROP_G_NAME_OWNER:
-      g_value_set_string (value, proxy->priv->name_owner);
+      g_value_take_string (value, g_dbus_proxy_get_name_owner (proxy));
       break;
 
     case PROP_G_OBJECT_PATH:
@@ -260,7 +260,7 @@ g_dbus_proxy_get_property (GObject    *object,
       break;
 
     case PROP_G_DEFAULT_TIMEOUT:
-      g_value_set_int (value, proxy->priv->timeout_msec);
+      g_value_set_int (value, g_dbus_proxy_get_default_timeout (proxy));
       break;
 
     case PROP_G_INTERFACE_INFO:
-- 
1.7.1


From 84cf735387877ff8cd96e76d90ab84cb25a1002d Mon Sep 17 00:00:00 2001
From: Simon McVittie <simon.mcvittie@collabora.co.uk>
Date: Mon, 8 Aug 2011 18:29:20 +0100
Subject: [PATCH 7/8] GDBusProxy: factor out async_init_data_set_name_owner

This removes the need for async_init_get_name_owner_cb to cope with being
called without a real GAsyncResult, and will simplify the addition of
correct thread-locking.

In async_init_data_set_name_owner, use the name_owner parameter instead
of the corresponding member of GDBusProxyPrivate, partly to reduce
pointer-chasing but mainly to avoid needing to hold the lock.

Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit 5909cb10315ca0f331ccb97225f008c11ca0d9d7)
---
 gio/gdbusproxy.c |   90 ++++++++++++++++++++++++++++--------------------------
 1 files changed, 47 insertions(+), 43 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 0646b98..22e501f 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -1248,46 +1248,16 @@ async_init_get_all_cb (GDBusConnection *connection,
   async_init_data_free (data);
 }
 
-
 static void
-async_init_get_name_owner_cb (GDBusConnection *connection,
-                              GAsyncResult    *res,
-                              gpointer         user_data)
+async_init_data_set_name_owner (AsyncInitData *data,
+                                const gchar   *name_owner)
 {
-  AsyncInitData *data = user_data;
   gboolean get_all;
 
-  if (res != NULL)
+  if (name_owner != NULL)
     {
-      GError *error;
-      GVariant *result;
-
-      error = NULL;
-      result = g_dbus_connection_call_finish (connection,
-                                              res,
-                                              &error);
-      if (result == NULL)
-        {
-          if (error->domain == G_DBUS_ERROR &&
-              error->code == G_DBUS_ERROR_NAME_HAS_NO_OWNER)
-            {
-              g_error_free (error);
-            }
-          else
-            {
-              g_simple_async_result_take_error (data->simple, error);
-              g_simple_async_result_complete_in_idle (data->simple);
-              async_init_data_free (data);
-              goto out;
-            }
-        }
-      else
-        {
-          g_variant_get (result,
-                         "(s)",
-                         &data->proxy->priv->name_owner);
-          g_variant_unref (result);
-        }
+      /* it starts as NULL anyway */
+      data->proxy->priv->name_owner = g_strdup (name_owner);
     }
 
   get_all = TRUE;
@@ -1297,8 +1267,7 @@ async_init_get_name_owner_cb (GDBusConnection *connection,
       /* Don't load properties if the API user doesn't want them */
       get_all = FALSE;
     }
-  else if (data->proxy->priv->name_owner == NULL &&
-           data->proxy->priv->name != NULL)
+  else if (name_owner == NULL && data->proxy->priv->name != NULL)
     {
       /* Don't attempt to load properties if the name_owner is NULL (which
        * usually means the name isn't owned), unless name is also NULL (which
@@ -1312,7 +1281,7 @@ async_init_get_name_owner_cb (GDBusConnection *connection,
     {
       /* load all properties asynchronously */
       g_dbus_connection_call (data->proxy->priv->connection,
-                              data->proxy->priv->name_owner,
+                              name_owner,
                               data->proxy->priv->object_path,
                               "org.freedesktop.DBus.Properties",
                               "GetAll",
@@ -1329,9 +1298,45 @@ async_init_get_name_owner_cb (GDBusConnection *connection,
       g_simple_async_result_complete_in_idle (data->simple);
       async_init_data_free (data);
     }
+}
 
- out:
-  ;
+static void
+async_init_get_name_owner_cb (GDBusConnection *connection,
+                              GAsyncResult    *res,
+                              gpointer         user_data)
+{
+  AsyncInitData *data = user_data;
+  GError *error;
+  GVariant *result;
+
+  error = NULL;
+  result = g_dbus_connection_call_finish (connection,
+                                          res,
+                                          &error);
+  if (result == NULL)
+    {
+      if (error->domain == G_DBUS_ERROR &&
+          error->code == G_DBUS_ERROR_NAME_HAS_NO_OWNER)
+        {
+          g_error_free (error);
+          async_init_data_set_name_owner (data, NULL);
+        }
+      else
+        {
+          g_simple_async_result_take_error (data->simple, error);
+          g_simple_async_result_complete_in_idle (data->simple);
+          async_init_data_free (data);
+        }
+    }
+  else
+    {
+      /* borrowed from result to avoid an extra copy */
+      const gchar *name_owner;
+
+      g_variant_get (result, "(&s)", &name_owner);
+      async_init_data_set_name_owner (data, name_owner);
+      g_variant_unref (result);
+    }
 }
 
 static void
@@ -1463,12 +1468,11 @@ async_initable_init_second_async (GAsyncInitable      *initable,
   if (proxy->priv->name == NULL)
     {
       /* Do nothing */
-      async_init_get_name_owner_cb (proxy->priv->connection, NULL, data);
+      async_init_data_set_name_owner (data, NULL);
     }
   else if (g_dbus_is_unique_name (proxy->priv->name))
     {
-      proxy->priv->name_owner = g_strdup (proxy->priv->name);
-      async_init_get_name_owner_cb (proxy->priv->connection, NULL, data);
+      async_init_data_set_name_owner (data, proxy->priv->name);
     }
   else
     {
-- 
1.7.1


From 723f836963c6c2d2bed821ad01e6f4baa271c098 Mon Sep 17 00:00:00 2001
From: Matthew Barnes <mbarnes@redhat.com>
Date: Tue, 9 Sep 2014 14:53:58 -0400
Subject: [PATCH 8/8] GDBusProxy: hold properties_lock while using any mutable property

This changes the meaning of "properties_lock" from "lock for D-Bus
properties" to "lock for GObject properties".

The most common problem, and the only one I've reproduced in a regression
test, is name_owner, which can be updated by the thread that owns
the GDBusProxy's main context (i.e. the thread-default main context of
the thread that constructed it) at the same time that a blocking call
is made. When a GDBusProxy is constructed in a thread-pool thread for
short-term use, the main context will typically be the global default
main context (which is actively running in the main thread!), making
this extremely problematic.

The interface info is perhaps a theoretical concern - one thread could
conceivably set it at the same time that another thread uses it, but only
in relatively pathological situations. The current API for this does have
the problem that it returns a borrowed ref, but interface info is
hopefully permanent anyway.

The default timeout is probably only a theoretical concern - it's just an
int, so writes are indivisible, and there's no worry about whether
something has been freed - but to be safe, let's hold the lock for that
too.

Bug: https://bugzilla.gnome.org/show_bug.cgi?id=656039
Bug-NB: NB#259760

Signed-off-by: David Zeuthen <davidz@redhat.com>

(cherry picked from commit 85214d1e7f1c1e065b2e05dae9d6cae29887e3d3)

Conflicts:

	gio/gdbusproxy.c
---
 gio/gdbusproxy.c |  115 ++++++++++++++++++++++++++++++++++++++++++++---------
 1 files changed, 95 insertions(+), 20 deletions(-)

diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 22e501f..b8d019d 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -85,7 +85,9 @@
  * <example id="gdbus-wellknown-proxy"><title>GDBusProxy for a well-known-name</title><programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="../../../../gio/tests/gdbus-example-watch-proxy.c"><xi:fallback>FIXME: MISSING XINCLUDE CONTENT</xi:fallback></xi:include></programlisting></example>
  */
 
-/* lock protecting the properties GHashTable */
+/* lock protecting the mutable properties: name_owner, timeout_msec,
+ * expected_interface, and the properties hash table
+ */
 G_LOCK_DEFINE_STATIC (properties_lock);
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -123,18 +125,21 @@ struct _GDBusProxyPrivate
 
   GDBusProxyFlags flags;
   gchar *name;
+  /* mutable, protected by properties_lock */
   gchar *name_owner;
   gchar *object_path;
   gchar *interface_name;
+  /* mutable, protected by properties_lock */
   gint timeout_msec;
 
   guint name_owner_changed_subscription_id;
 
   GCancellable *get_all_cancellable;
 
-  /* gchar* -> GVariant* */
+  /* gchar* -> GVariant*, protected by properties_lock */
   GHashTable *properties;
 
+  /* mutable, protected by properties_lock */
   GDBusInterfaceInfo *expected_interface;
 
   guint properties_changed_subscription_id;
@@ -651,6 +656,9 @@ g_dbus_proxy_get_cached_property_names (GDBusProxy  *proxy)
   return names;
 }
 
+/* properties_lock must be held for as long as you will keep the
+ * returned value
+ */
 static const GDBusPropertyInfo *
 lookup_property_info_or_warn (GDBusProxy  *proxy,
                               const gchar *property_name)
@@ -818,7 +826,7 @@ on_signal_received (GDBusConnection *connection,
   if (proxy == NULL)
     {
       G_UNLOCK (signal_subscription_lock);
-      goto out;
+      return;
     }
   else
     {
@@ -829,8 +837,15 @@ on_signal_received (GDBusConnection *connection,
   if (!proxy->priv->initialized)
     goto out;
 
+  G_LOCK (properties_lock);
+
   if (proxy->priv->name_owner != NULL && g_strcmp0 (sender_name, proxy->priv->name_owner) != 0)
-    goto out;
+    {
+      G_UNLOCK (properties_lock);
+      goto out;
+    }
+
+  G_UNLOCK (properties_lock);
 
   g_signal_emit (proxy,
                  signals[SIGNAL_SIGNAL],
@@ -838,6 +853,7 @@ on_signal_received (GDBusConnection *connection,
                  sender_name,
                  signal_name,
                  parameters);
+
  out:
   if (proxy != NULL)
     g_object_unref (proxy);
@@ -884,13 +900,19 @@ on_properties_changed (GDBusConnection *connection,
   if (!proxy->priv->initialized)
     goto out;
 
+  G_LOCK (properties_lock);
+
   if (proxy->priv->name_owner != NULL && g_strcmp0 (sender_name, proxy->priv->name_owner) != 0)
-    goto out;
+    {
+      G_UNLOCK (properties_lock);
+      goto out;
+    }
 
   if (!g_variant_is_of_type (parameters, G_VARIANT_TYPE ("(sa{sv}as)")))
     {
       g_warning ("Value for PropertiesChanged signal with type `%s' does not match `(sa{sv}as)'",
                  g_variant_get_type_string (parameters));
+      G_UNLOCK (properties_lock);
       goto out;
     }
 
@@ -901,9 +923,10 @@ on_properties_changed (GDBusConnection *connection,
                  &invalidated_properties);
 
   if (g_strcmp0 (interface_name_for_signal, proxy->priv->interface_name) != 0)
-    goto out;
-
-  G_LOCK (properties_lock);
+    {
+      G_UNLOCK (properties_lock);
+      goto out;
+    }
 
   g_variant_iter_init (&iter, changed_properties);
   while (g_variant_iter_next (&iter, "{sv}", &key, &value))
@@ -1030,11 +1053,10 @@ on_name_owner_changed_get_all_cb (GDBusConnection *connection,
   /* and finally we can notify */
   if (!cancelled)
     {
+      G_LOCK (properties_lock);
       g_free (data->proxy->priv->name_owner);
       data->proxy->priv->name_owner = data->name_owner;
       data->name_owner = NULL; /* to avoid an extra copy, we steal the string */
-
-      G_LOCK (properties_lock);
       g_hash_table_remove_all (data->proxy->priv->properties);
       G_UNLOCK (properties_lock);
       if (result != NULL)
@@ -1097,11 +1119,10 @@ on_name_owner_changed (GDBusConnection *connection,
 
   if (strlen (new_owner) == 0)
     {
+      G_LOCK (properties_lock);
       g_free (proxy->priv->name_owner);
       proxy->priv->name_owner = NULL;
 
-      G_LOCK (properties_lock);
-
       /* Synthesize ::g-properties-changed changed */
       if (!(proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES) &&
           g_hash_table_size (proxy->priv->properties) > 0)
@@ -1142,15 +1163,20 @@ on_name_owner_changed (GDBusConnection *connection,
     }
   else
     {
+      G_LOCK (properties_lock);
+
       /* ignore duplicates - this can happen when activating the service */
       if (g_strcmp0 (new_owner, proxy->priv->name_owner) == 0)
-        goto out;
+        {
+          G_UNLOCK (properties_lock);
+          goto out;
+        }
 
       if (proxy->priv->flags & G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES)
         {
           g_free (proxy->priv->name_owner);
           proxy->priv->name_owner = g_strdup (new_owner);
-          G_LOCK (properties_lock);
+
           g_hash_table_remove_all (proxy->priv->properties);
           G_UNLOCK (properties_lock);
           g_object_notify (G_OBJECT (proxy), "g-name-owner");
@@ -1159,6 +1185,8 @@ on_name_owner_changed (GDBusConnection *connection,
         {
           LoadPropertiesOnNameOwnerChangedData *data;
 
+          G_UNLOCK (properties_lock);
+
           /* start loading properties.. only then emit notify::g-name-owner .. we
            * need to be able to cancel this in the event another NameOwnerChanged
            * signal suddenly happens
@@ -1254,10 +1282,13 @@ async_init_data_set_name_owner (AsyncInitData *data,
 {
   gboolean get_all;
 
+
   if (name_owner != NULL)
     {
       /* it starts as NULL anyway */
+      G_LOCK (properties_lock);
       data->proxy->priv->name_owner = g_strdup (name_owner);
+      G_UNLOCK (properties_lock);
     }
 
   get_all = TRUE;
@@ -2121,8 +2152,14 @@ g_dbus_proxy_get_name (GDBusProxy *proxy)
 gchar *
 g_dbus_proxy_get_name_owner (GDBusProxy *proxy)
 {
+  gchar *ret;
+
   g_return_val_if_fail (G_IS_DBUS_PROXY (proxy), NULL);
-  return g_strdup (proxy->priv->name_owner);
+
+  G_LOCK (properties_lock);
+  ret = g_strdup (proxy->priv->name_owner);
+  G_UNLOCK (properties_lock);
+  return ret;
 }
 
 /**
@@ -2176,8 +2213,14 @@ g_dbus_proxy_get_interface_name (GDBusProxy *proxy)
 gint
 g_dbus_proxy_get_default_timeout (GDBusProxy *proxy)
 {
+  gint ret;
+
   g_return_val_if_fail (G_IS_DBUS_PROXY (proxy), -1);
-  return proxy->priv->timeout_msec;
+
+  G_LOCK (properties_lock);
+  ret = proxy->priv->timeout_msec;
+  G_UNLOCK (properties_lock);
+  return ret;
 }
 
 /**
@@ -2200,12 +2243,19 @@ g_dbus_proxy_set_default_timeout (GDBusProxy *proxy,
   g_return_if_fail (G_IS_DBUS_PROXY (proxy));
   g_return_if_fail (timeout_msec == -1 || timeout_msec >= 0);
 
-  /* TODO: locking? */
+  G_LOCK (properties_lock);
+
   if (proxy->priv->timeout_msec != timeout_msec)
     {
       proxy->priv->timeout_msec = timeout_msec;
+      G_UNLOCK (properties_lock);
+
       g_object_notify (G_OBJECT (proxy), "g-default-timeout");
     }
+  else
+    {
+      G_UNLOCK (properties_lock);
+    }
 }
 
 /**
@@ -2225,8 +2275,17 @@ g_dbus_proxy_set_default_timeout (GDBusProxy *proxy,
 GDBusInterfaceInfo *
 g_dbus_proxy_get_interface_info (GDBusProxy *proxy)
 {
+  GDBusInterfaceInfo *ret;
+
   g_return_val_if_fail (G_IS_DBUS_PROXY (proxy), NULL);
-  return proxy->priv->expected_interface;
+
+  G_LOCK (properties_lock);
+  ret = proxy->priv->expected_interface;
+  G_UNLOCK (properties_lock);
+  /* FIXME: returning a borrowed ref with no guarantee that nobody will
+   * call g_dbus_proxy_set_interface_info() and make it invalid...
+   */
+  return ret;
 }
 
 /**
@@ -2249,9 +2308,13 @@ g_dbus_proxy_set_interface_info (GDBusProxy         *proxy,
                                  GDBusInterfaceInfo *info)
 {
   g_return_if_fail (G_IS_DBUS_PROXY (proxy));
+  G_LOCK (properties_lock);
+
   if (proxy->priv->expected_interface != NULL)
     g_dbus_interface_info_unref (proxy->priv->expected_interface);
   proxy->priv->expected_interface = info != NULL ? g_dbus_interface_info_ref (info) : NULL;
+
+  G_UNLOCK (properties_lock);
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
@@ -2317,6 +2380,9 @@ reply_cb (GDBusConnection *connection,
   g_object_unref (simple);
 }
 
+/* properties_lock must be held for as long as you will keep the
+ * returned value
+ */
 static const GDBusMethodInfo *
 lookup_method_info_or_warn (GDBusProxy  *proxy,
                             const gchar *method_name)
@@ -2336,6 +2402,9 @@ lookup_method_info_or_warn (GDBusProxy  *proxy,
   return info;
 }
 
+/* properties_lock must be held for as long as you will keep the
+ * returned value
+ */
 static const gchar *
 get_destination_for_call (GDBusProxy *proxy)
 {
@@ -2428,7 +2497,7 @@ g_dbus_proxy_call (GDBusProxy          *proxy,
   const gchar *split_method_name;
   const gchar *target_method_name;
   const gchar *target_interface_name;
-  const gchar *destination;
+  gchar *destination;
   GVariantType *reply_type;
 
   g_return_if_fail (G_IS_DBUS_PROXY (proxy));
@@ -2444,6 +2513,8 @@ g_dbus_proxy_call (GDBusProxy          *proxy,
                                       user_data,
                                       g_dbus_proxy_call);
 
+  G_LOCK (properties_lock);
+
   was_split = maybe_split_method_name (method_name, &split_interface_name, &split_method_name);
   target_method_name = was_split ? split_method_name : method_name;
   target_interface_name = was_split ? split_interface_name : proxy->priv->interface_name;
@@ -2460,17 +2531,20 @@ g_dbus_proxy_call (GDBusProxy          *proxy,
   destination = NULL;
   if (proxy->priv->name != NULL)
     {
-      destination = get_destination_for_call (proxy);
+      destination = g_strdup (get_destination_for_call (proxy));
       if (destination == NULL)
         {
           g_simple_async_result_set_error (simple,
                                            G_IO_ERROR,
                                            G_IO_ERROR_FAILED,
                                            _("Cannot invoke method; proxy is for a well-known name without an owner and proxy was constructed with the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag"));
+          G_UNLOCK (properties_lock);
           goto out;
         }
     }
 
+  G_UNLOCK (properties_lock);
+
   g_dbus_connection_call (proxy->priv->connection,
                           destination,
                           proxy->priv->object_path,
@@ -2488,6 +2562,7 @@ g_dbus_proxy_call (GDBusProxy          *proxy,
   if (reply_type != NULL)
     g_variant_type_free (reply_type);
 
+  g_free (destination);
   g_free (split_interface_name);
 }
 
-- 
1.7.1

